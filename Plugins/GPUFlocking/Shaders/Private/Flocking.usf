
struct FState_GPU
{
    int instanceId;
    float3 position;
    float3 velocity;
    float3 acceleration;
};

RWTexture2D<uint> OutputTexture;
extern float simulationTime;
precise extern RWStructuredBuffer<float> StepTotal;

RWStructuredBuffer<TState> data;

//RWStructuredBuffer<float> data;

//each x,y,z of numthreads is multiplied by the respective DispatchShader x,y,z
//So for 1024x1024 threads, we could do:
//DispatchShader (32,32,1) in cpp
//numthreads(32,32,1) in usf
//equals (1024,1024,1)!
//Then you can just use ThreadId.xy for each pixel without fancy math (using a 1024x1024 texture)
[numthreads(16, 16, 1)]
//If using more than 1,1,1, threads:
//Be aware that parrellel thread are running, make sure that no thread can stomp on another threads calculations by
//writing to the same buffer/texture point
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{	
    float val = abs(sin(simulationTime));
    
    StepTotal[0] = 99.0f;
    StepTotal[1] = 2.0f;
    
    OutputTexture[ThreadId.xy] = float4(val, 1, 0, 1);
}
