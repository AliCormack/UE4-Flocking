
struct FState_GPU
{
    int instanceId;
    float3 position;
    float3 velocity;
    float3 acceleration;
};

RWTexture2D<uint> OutputTexture;
extern float simulationTime;
//precise extern RWStructuredBuffer<float> StepTotal;

precise extern RWStructuredBuffer<FState_GPU> Data;

//RWStructuredBuffer<float> data;

//each x,y,z of numthreads is multiplied by the respective DispatchShader x,y,z
//So for 1024x1024 threads, we could do:
//DispatchShader (32,32,1) in cpp
//numthreads(32,32,1) in usf
//equals (1024,1024,1)!
//Then you can just use ThreadId.xy for each pixel without fancy math (using a 1024x1024 texture)
[numthreads(16, 16, 1)]
//If using more than 1,1,1, threads:
//Be aware that parrellel thread are running, make sure that no thread can stomp on another threads calculations by
//writing to the same buffer/texture point
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{	
    float val = abs(sin(simulationTime));
    
    FState_GPU state;
    state.instanceId = 99;
    state.position = float3(0, 1, 1);
    state.velocity = float3(0, 1, 1);
    state.acceleration = float3(0, 1, 1);
    
    Data[0] = state;
    
    FState_GPU state2;
    state2.instanceId = 99;
    state2.position = float3(0, 1, 1);
    state2.velocity = float3(0, 1, 1);
    state2.acceleration = float3(0, 1, 1);
    
    Data[1] = state2;
    
    OutputTexture[ThreadId.xy] = float4(val, 1, 0, 1);
}
